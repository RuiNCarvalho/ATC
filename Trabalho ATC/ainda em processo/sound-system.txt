// sound_system.h
#ifndef SOUND_SYSTEM_H
#define SOUND_SYSTEM_H

#include <SDL2/SDL.h>
#include <SDL2/SDL_mixer.h>
#include <string>
#include <map>
#include <memory>

// Enumeração para identificar os diferentes sons do jogo
enum class SoundEffect {
    WAKAWAKA,      // Som do Pacman comendo pastilhas
    POWER_PELLET,  // Som ao pegar power pellet
    GHOST_EATEN,   // Som ao comer um fantasma
    DEATH,         // Som da morte do Pacman
    GAME_START,    // Som do início do jogo
    GAME_OVER,     // Som de game over
    SIREN,         // Som de fundo durante o jogo
    GHOST_SCARED   // Som quando os fantasmas estão assustados
};

class SoundSystem {
private:
    static SoundSystem* instance;
    std::map<SoundEffect, Mix_Chunk*> soundEffects;
    Mix_Music* backgroundMusic;
    bool isMuted;

    // Construtor privado (Singleton)
    SoundSystem();

public:
    // Evita cópias do Singleton
    SoundSystem(const SoundSystem&) = delete;
    SoundSystem& operator=(const SoundSystem&) = delete;

    static SoundSystem* getInstance();
    ~SoundSystem();

    // Inicialização e limpeza
    bool initialize();
    void cleanup();

    // Controle de som
    void playSound(SoundEffect effect);
    void stopSound(SoundEffect effect);
    void playBackgroundMusic();
    void stopBackgroundMusic();
    void pauseBackgroundMusic();
    void resumeBackgroundMusic();

    // Controle de volume
    void setVolume(int volume); // 0-128
    void setMusicVolume(int volume); // 0-128
    void toggleMute();

    // Status
    bool isPlaying(SoundEffect effect) const;
    bool isMusicPlaying() const;
    bool getMuted() const;

private:
    bool loadSoundEffects();
    bool loadBackgroundMusic(const std::string& musicFile);
};

#endif // SOUND_SYSTEM_H

// sound_system.cpp
#include "sound_system.h"
#include <iostream>

SoundSystem* SoundSystem::instance = nullptr;

SoundSystem::SoundSystem() 
    : backgroundMusic(nullptr), isMuted(false) {
}

SoundSystem* SoundSystem::getInstance() {
    if (instance == nullptr) {
        instance = new SoundSystem();
    }
    return instance;
}

bool SoundSystem::initialize() {
    // Inicializa o SDL com suporte a áudio
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        std::cerr << "SDL não pode ser iniciado: " << SDL_GetError() << std::endl;
        return false;
    }

    // Inicializa o SDL_mixer
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        std::cerr << "SDL_mixer não pode ser iniciado: " << Mix_GetError() << std::endl;
        return false;
    }

    // Carrega todos os efeitos sonoros
    if (!loadSoundEffects()) {
        std::cerr << "Falha ao carregar efeitos sonoros" << std::endl;
        return false;
    }

    // Carrega a música de fundo
    if (!loadBackgroundMusic("assets/sounds/background.wav")) {
        std::cerr << "Falha ao carregar música de fundo" << std::endl;
        return false;
    }

    return true;
}

bool SoundSystem::loadSoundEffects() {
    // Carrega cada efeito sonoro
    const std::string soundPath = "assets/sounds/";
    std::map<SoundEffect, std::string> soundFiles = {
        {SoundEffect::WAKAWAKA, "wakawaka.wav"},
        {SoundEffect::POWER_PELLET, "power_pellet.wav"},
        {SoundEffect::GHOST_EATEN, "ghost_eaten.wav"},
        {SoundEffect::DEATH, "death.wav"},
        {SoundEffect::GAME_START, "game_start.wav"},
        {SoundEffect::GAME_OVER, "game_over.wav"},
        {SoundEffect::SIREN, "siren.wav"},
        {SoundEffect::GHOST_SCARED, "ghost_scared.wav"}
    };

    for (const auto& [effect, filename] : soundFiles) {
        std::string fullPath = soundPath + filename;
        Mix_Chunk* sound = Mix_LoadWAV(fullPath.c_str());
        
        if (sound == nullptr) {
            std::cerr << "Falha ao carregar som: " << fullPath << std::endl;
            std::cerr << "Erro SDL_mixer: " << Mix_GetError() << std::endl;
            return false;
        }
        
        soundEffects[effect] = sound;
    }

    return true;
}

bool SoundSystem::loadBackgroundMusic(const std::string& musicFile) {
    backgroundMusic = Mix_LoadMUS(musicFile.c_str());
    if (backgroundMusic == nullptr) {
        std::cerr << "Falha ao carregar música: " << musicFile << std::endl;
        std::cerr << "Erro SDL_mixer: " << Mix_GetError() << std::endl;
        return false;
    }
    return true;
}

void SoundSystem::playSound(SoundEffect effect) {
    if (!isMuted && soundEffects.count(effect) > 0) {
        Mix_PlayChannel(-1, soundEffects[effect], 0);
    }
}

void SoundSystem::stopSound(SoundEffect effect) {
    if (soundEffects.count(effect) > 0) {
        // Para todos os canais tocando este efeito
        Mix_HaltChannel(-1);
    }
}

void SoundSystem::playBackgroundMusic() {
    if (!isMuted && backgroundMusic != nullptr) {
        Mix_PlayMusic(backgroundMusic, -1); // -1 para loop infinito
    }
}

void SoundSystem::stopBackgroundMusic() {
    Mix_HaltMusic();
}

void SoundSystem::pauseBackgroundMusic() {
    Mix_PauseMusic();
}

void SoundSystem::resumeBackgroundMusic() {
    if (!isMuted) {
        Mix_ResumeMusic();
    }
}

void SoundSystem::setVolume(int volume) {
    volume = std::max(0, std::min(volume, 128));
    Mix_Volume(-1, volume); // -1 ajusta todos os canais
}

void SoundSystem::setMusicVolume(int volume) {
    volume = std::max(0, std::min(volume, 128));
    Mix_VolumeMusic(volume);
}

void SoundSystem::toggleMute() {
    isMuted = !isMuted;
    if (isMuted) {
        Mix_VolumeMusic(0);
        Mix_Volume(-1, 0);
    } else {
        Mix_VolumeMusic(128);
        Mix_Volume(-1, 128);
    }
}

bool SoundSystem::isPlaying(SoundEffect effect) const {
    return Mix_Playing(-1) > 0;
}

bool SoundSystem::isMusicPlaying() const {
    return Mix_PlayingMusic() == 1;
}

bool SoundSystem::getMuted() const {
    return isMuted;
}

void SoundSystem::cleanup() {
    // Libera todos os efeitos sonoros
    for (auto& [effect, sound] : soundEffects) {
        if (sound != nullptr) {
            Mix_FreeChunk(sound);
            sound = nullptr;
        }
    }
    soundEffects.clear();

    // Libera a música de fundo
    if (backgroundMusic != nullptr) {
        Mix_FreeMusic(backgroundMusic);
        backgroundMusic = nullptr;
    }

    // Fecha o SDL_mixer e SDL
    Mix_CloseAudio();
    Mix_Quit();
    SDL_Quit();
}

SoundSystem::~SoundSystem() {
    cleanup();
}
